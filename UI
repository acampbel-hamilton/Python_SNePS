#!/usr/local/bin/python3.5


#### Note: str and repr methods should be rewritten to provide a more
####		informative and asceticaly pleasing representation of the
####		appropriate object

import re
from Symbol import *
from Network import *

import os
from functools import reduce
from cmd import Cmd

class UI(Cmd):
	network = None
	cmds = ""
	slot_filler = "\((\s*\w+)+\s*\)\s*"
	qstr = "\"(\s*\w+)+\s*\""
	arg_gen = "\s+\w+\s*"

	def __init__(self, completekey='tab', stdin=None, stdout=None):
		self.recur = False
		super().__init__(completekey, stdin, stdout)

	def preloop(self):
		UI.network = Network()
		UI.network.initialize()

	def precmd(self, line):
		self.recur = True
		line = re.sub('\s+', ' ', line)
		return line

	def onecmd(self, line):
		"""error handling"""
		res = None
		try:
			res = super().onecmd(line)
		except AssertionError as AE:
			print(AE)
		return res

	def postcmd(self, stop, line):
		self.recur = False

	def _reval(self, args): #this can change the network even if an error occurs
		"""recursively evaluates the arguments to any do_* method, allowing the
		only appropriate functions to be used as arguments"""
		if not UI.cmds: #create and store the list, instead of computing on call
			UI.cmds = "|".join(map((lambda s: s[3:]),
					filter((lambda i: re.match("^do_\w+$", i) is not None),
					[m for m in dir(self) if callable(getattr(self, m))])))
		subcmd = re.compile("\(\s*((?:{})\s+((?:{})|(?:{})|(?:{}))+)\)"
			.format(UI.cmds, UI.slot_filler, UI.qstr, UI.arg_gen))
		while subcmd.search(args) is not None:
			args = subcmd.sub((lambda mobj: self.onecmd(mobj.group(1))), args)
		return args

	def _parse_path(self, pstr):
		"""parses a path expression passed as a string and returns nested lists
		representing the path"""
		path = []
		lst = path
		word = ''
		count = 0
		for c in pstr:
			if c in [' ', '\t']:
				lst.append(word)
				word = ''
			elif c == '(':
				if word:
					lst.append(word)
					word = ''
				lst.append([])
				lst = lst[-1]
				count += 1
			elif c == ')':
				if word:
					lst.append(word)
					word = ''
				lst = eval('path' + '[-1]'*count)
				count -= 1
			else:
				word += c
		return path

################ USER METHODS ################

	def do_ask(self, args):
		"""triggers forward inference and attempts to prove the given expression"""
		frames = '(?:' + '|'.join(UI.network.caseframes.keys()) + ')'
		filler = '(?:\w+|\((?:\s*\w+)+\s*\))'.format(frames)

		case = re.compile('(?P<begin>.*)(\s*\(\s*(?P<frame>{})\s+(?P<fill>(?:\s*{})+)\s*\))'
			.format(frames, filler))
		if case is None:
			print("Invalid input {} to ask".format(args))
			return
		dict =  case.search(args).groupdict()
		cf = UI.network.caseframes.get(dict['frame'])
		fill = [[n] for n in dict['fill'].split()]
		prop, _ = UI.network.construct(cf, fill)
		if prop is None:
			return
		UI.network.askif(prop)

	def do_assert(self, args):
		"""Builds and asserts the specified molecular term and adds it to the network.\nIf an identical object exists, the existing object is returned"""
		args = re.sub("(^\s*\()|(\)\s*$)", "", args) #strip outer parentheses
		frames = '(?:' + '|'.join(UI.network.caseframes.keys()) + ')'
		filler = '(?:\w+|\((?:\s*\w+)+\s*\))'
		case = re.compile('(?P<begin>.*)(\s*\(\s*(?P<frame>{})\s+(?P<fill>(?:\s*{})+)\s*\))'
			.format(frames, filler))
		while case.search(args) is not None: #only build internal nodes
			args = case.sub((lambda m: '{} {} '.format(m.group("begin"),
					UI.network.casebuild(m.group("frame"), m.group("fill")).name)),
					args)
		if not case.search('(' + args + ')'):
			print("Invalid input: {}".format(args))
			return
		args = case.sub((lambda m: '{} {} '.format(m.group("begin"),
				UI.network.casebuild(m.group('frame'), m.group('fill'), uassert=True))),
				'(' + args + ')') #assert main node
		return args

	def do_build(self, args):
		"""Builds the specified molecular term and adds it to the network.\nIf an identical object exists, the existing object is returned"""
		# rel = '(?:' + '|'.join(UI.network.slots.keys()) + ')'
		frames = '(?:' + '|'.join(UI.network.caseframes.keys()) + ')'
		filler = '(?:\w+|\((?:\s*\w+)+\s*\))'.format(frames)
		# prim = re.findall('\s*({})\s+({})'.format(rel, filler), args)
		case = re.compile('(?P<begin>.*)(\s*\(\s*(?P<frame>{})\s+(?P<fill>(?:\s*{})+)\s*\))'
			.format(frames, filler))
		while case.search(args) is not None:
			args = case.sub((lambda m: '{} {} '.format(m.group("begin"),
					UI.network.casebuild(m.group('frame'), m.group('fill')).name)),
					args)
		return args

	def do_clear(self, args):
		"""calls bash clear command"""
		os.system('clear')

	def do_defContext(self, args):
		"""defines a new caseframe as specified by arguments in the form:\ndefinedContext [name] \"[docstring]\" ([parents]) ([hyps])"""
		m = re.match("^(?P<name>\s*\w+)\s*" + \
					"(?P<docstr>{})?".format(UI.qstr) + \
					"(?(docstr)\s+\((?P<parents>(\s*\w+)+)\s*\))?" + \
					"(?(parents)\s+\((?P<hyps>(\s*\w+)+)\s*\)\s*)?$",args)
		param = [m.group('name'), m.group('docstr'),
				set(m.group('parents').split()), set(m.group('hyps').split())]
		count = None
		if m is None:
			print("Inappropriate number of arguments to defineContext")
			return
		elif m.group('hyps'):
			count = 4
		elif m.group('parents'):
			count = 3
		elif m.group('docstr'):
			count = 2
		else:
			count = 1
		UI.network.defineContext(*param[:count])

	def do_defFrame(self, args):
		"""defines a new caseframe as specified by arguments in the form:\ndefFrame [name] [semantic type] ([slots]) \"[docstring]\'"""
		args = re.match("^\s*(?P<name>\w+)\s+" +\
						"(?P<semtype>\w+)\s+" +\
						"\((?P<slots>(\s*\w+)+)\)\s+" +\
						"(?P<docstr>{})?$".format(UI.qstr)
				, args)
		if args is not None:
			UI.network.defineCaseframe(args.group('name'),
										args.group('semtype'),
										args.group('slots').split(),
										args.group('docstr'))
		else:
			print("Invalid arguments to defFrame")

	def do_defPath(self, args):
		"""Defines path rule for path based inference"""
		m = re.match('^\s*(?P<slot>{})\s+(?P<path>.*)$'
						.format('|'.join(UI.network.slots.keys())),
					args)
		if m is None:
			print("Error: incorrect format for defPath command")
			return
		UI.network.definePath(m.group('slot'), self._parse_path(m.group('path'))[0])

	def do_defSlot(self, args):
		"""defines a new slot as specified by arguments in the form:\ndefSlot [name] [type] \"[docstring]\" [pos_adj] [neg_adj] [min] [max]"""
		args = re.match("^\s*(?P<name>\w+)" +\
						"\s+(?P<semtype>\w+)" +\
						"\s+(?P<docstr>{})".format(UI.qstr) +\
						"\s*(?(docstr)(?P<posadj>(reduce|expand|none)))?" +\
						"\s*(?(posadj)(?P<negadj>(reduce|expand|none)))?" +\
						"\s*(?(negadj)(?P<min>\d+))?" +\
						"\s*(?(min)(?P<max>\d+))?"
						, args)

		if args is None:
			print("Invalid arguments to defSlot")
		elif args.group('max'):
			UI.network.defineSlot(args.group('name'), args.group('semtype'),
				args.group('docstr'), args.group('posadj'), args.group('negadj')
				, int(args.group('min')), int(args.group('max')))
		elif args.group('min'):
			UI.network.defineSlot(args.group('name'), args.group('semtype'),
				args.group('docstr'), args.group('posadj'), args.group('negadj')
				, int(args.group('min')))
		elif args.group('negadj'):
			UI.network.defineSlot(args.group('name'), args.group('semtype'),
				args.group('docstr'), args.group('posadj'), args.group('negadj'))
		elif args.group('posadj'):
			UI.network.defineSlot(args.group('name'), args.group('semtype'),
				args.group('docstr'), args.group('posadj'))
		else:
			UI.network.defineSlot(args.group('name'), args.group('semtype'),
				args.group('docstr'))

	def do_describe(self, args):
		"""Prints a representation of the object specified by name"""
		name = self._reval(args).split()[0]
		if UI.network.terms.get(name):
			print(UI.network.terms.get(name))
		elif UI.network.caseframes.get(name):
			print(UI.network.caseframes.get(name))
		elif UI.network.slots.get(name):
			print(UI.network.slots.get(name))
		elif UI.network.contexts.get(name):
			print(UI.network.contexts.get(name))
		else:
			print("Given name does not correspond to any object.")

	def do_dump(self, args):
		"""Prints the network. Should be rewritten"""
		print(UI.network)

	def do_exit(self, args):
		"""Exits the PySNePS UI"""
		print("Exiting PySNePS")
		raise SystemExit

	def do_find(self, args):
		"""Returns a node set containing all nodes which satisfy the given constraints.\nConstraints have the format: [path] [node]"""
		r = re.compile("\s*(?P<path>(?:\(?:(?:\s*[\w\-!]+)+?\s*\))|\w+)\s+(?P<terminal>\w+)")
		l = r.findall(args)
		print(l)
		if not l:
			print("No compatible terms found")
			return
		node_set = []
		for param in l:
			subns = UI.network.traverse(param[1], UI.network.converse(param[0]))
			print(subns)
			node_set.append(subns)
		result = set()
		print(node_set)
		for term in node_set[0]:
			if node_set[1:] and all([(term in lst) for lst in node_set[1:]])\
				and UI.network.isAsserted(term):
				result.append(term.name)
		for i in result:
			print(i)
		return result

	def do_list(self, args):
		"""Lists all instances defined on the network of the given object"""
		args = args.split()[0]
		if args == []:
			return
		if args in ["caseframe", "caseframes"]:
			UI.network.listCaseframe()
		elif args in ["context", "contexts"]:
			UI.network.listContexts()
		elif args in ["semantic", "semantictype", "semantictypes"]:
			UI.network.listSemanticTypes()
		elif args in ["slot", "slots"]:
			UI.network.listSlots()
		elif args in ["term", "terms"]:
			print(*sorted(UI.network.terms.keys()), sep='\n')
		else:
			print("Error: Invalid argument to list")

	def do_shell(self, s):
		"""executes shell commands"""
		try:
			print(eval(s))
		except:
			print("Python incompatible with limited interpreter")



if __name__ == "__main__":
	prompt = UI()
	prompt.prompt = '[> '
	prompt.cmdloop("Welcome to the rudimentary UI for PySNePS!")
