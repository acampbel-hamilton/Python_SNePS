#!/usr/local/bin/python3.5

import re
from Symbol import *
from Network import *
from LisParse import parse

import os
from cmd import Cmd

class UI(Cmd):
	network = None

	def __init__(self, completekey='tab', stdin=None, stdout=None):
		self.line = ""
		super().__init__(completekey, stdin, stdout)

	def preloop(self):
		UI.network = Network()
		UI.network.initialize()

	def precmd(self, line):
		if line[0] == '(' and line[-1] == ')':
			self.line = line
			line = line[1:-1]
		else:
			self.line = '(' + line + ')'
		return line

################ USER METHODS ################

	def do_build(self, args):
		"""Builds the specified term and adds it to the network.
		If an identical object exists, the existing object is returned"""
		slots = parse(self.line)[0][1:]
		if not all([len(slot) > 1 for slot in slots]):
			print("Build command contains an unfilled slot")
			return
		rels, fillers = [list(l) for l in zip(*[(slot[0], slot[1:])
		 										for slot in slots])]
		for r in rels: # slots must be defined
			if not r in UI.network.slots.keys():
				print("Error: Use of undefined slot {}".format(r))
				return
		if not len(rels) == len(set(rels)): #slots must be unique
			print("Error: Repeated slot")
			return
		cf = None
		for c in UI.network.caseframes.values():
			if set(c.slots) == set(rels):
				cf = c
				break
		if cf is None: #specified slots correspond to an existing caseframe
			print("Error: No caseframe with given slots <{}> is defined"
				.format(str(rels)[1:-1]))
			return
		#if undefined terms are used, define them
		for n in [i for sl in fillers for i in sl]:
			if not n in UI.network.terms.keys():
				UI.network.terms[Sym(n)] = Term(n)
		for term in UI.network.terms.values(): #no identical term exists
			if isinstance(term, Molecular) and term.caseframe == cf and\
				[sorted(sl) for sl in sorted(fillers)] ==\
				 [sorted(sl) for sl in sorted(term.down_cableset.values())]:
				 print("Identical Term <{}>".format(repr(term)))
				 return
		Molecular.counter += 1
		term  = Molecular(Sym("M{}".format(Molecular.counter)), cf,
					down_cableset=dict(zip(rels, fillers)))
		UI.network.terms[Sym(term.name)] = term
		cf.terms.add(Sym(term.name))
		for i in range(len(rels)):
			for n in fillers[i]:
				UI.network.terms[n].up_cableset.update(
				{Sym(rels[i]):(UI.network.terms[n].up_cableset\
					.get(Sym(rels[i]), []) + [Sym(term.name)])})

	def do_clear(self, args):
		""""calls bash clear command"""
		os.system('clear')

	def do_defineFrame(self, args):
		"""defines a new caseframe as specified by arguments
		in the form: defineFrame [name] [semantic type] ([slots]) ([docstring])"""
		par = parse(self.line)[0]
		UI.network.defineCaseframe(par[1], par[2], par[3], " ".join(par[4]))

	def do_definePath(self, args):
		"""Defines path rule for path based inference"""
		par = parse(self.line)[0]
		UI.network.definePath(par[1], par[2])


	def do_describe(self, args):
		"""Prints a representation of the object specified by name"""
		name = args.split()[0]
		if UI.network.terms.get(name):
			print(UI.network.terms.get(name))
		elif UI.network.caseframes.get(name):
			print(UI.network.caseframes.get(name))
		elif UI.network.slots.get(name):
			print(UI.network.slots.get(name))
		elif UI.network.contexts.get(name):
			print(UI.network.contexts.get(name))
		else:
			print("Given name does not correspond to any object.")

	def do_dump(self, args):
		"""Prints the network. Should be rewritten"""
		print(UI.network)

	def do_exit(self, args):
		"""Exits the PySNePS UI"""
		print("Exiting PySNePS")
		raise SystemExit

	def do_list(self, args):
		"""Lists all instances defined on the network of the given object"""
		par = parse(self.line)[0][1:]
		if par == []:
			return
		if par[0] in ["caseframe", "caseframes"]:
			UI.network.listCaseframe()
		elif par[0] in ["context", "contexts"]:
			UI.network.listContexts()
		elif par[0] in ["semantic", "semantictype", "semantictypes"]:
			UI.network.listSemanticTypes()
		elif par[0] in ["slot", "slots"]:
			UI.network.listSlots()
		else:
			print("Error: Invalid argument to list")

	def do_shell(self, s):
		"""executes shell commands"""
		try:
			print(eval(s))
		except:
			print("Python incompatible with limited interpreter")






if __name__ == "__main__":
	prompt = UI()
	prompt.prompt = '[> '
	prompt.cmdloop("Welcome to the rudimentary UI for PySNePS!")

# print("Welcome to the rudimentary User Interface for PSNePS")
#
# cmd = ""
# net = Network()
# net.initialize()
# while not cmd == "exit":
# 	usrin = input("[> ").strip()
# 	if not usrin[0] == '(':
# 		usrin = '(' + usrin + ')'
# 	par = parse(usrin)
# 	cmd = par[0][0]
# 	if cmd == "describe":
# 		pass
# 	elif cmd == "dump":
# 		print(net)
# 	elif cmd == "list":
# 		type = par[0][1]
# 		if type in ["semantic", "semantictype", "semantictypes"]:
# 			net.listSemanticTypes()
# 		elif type in ["caseframe", "caseframes"]:
# 			net.listCaseframe()
# 		elif type in ["context", "contexts"]:
# 			net.listContexts()
# 		elif type in ["slot", "slots"]:
# 			net.listSlots()
# 		else:
# 			print("Invalid list option.")
# 	print(par)
#
#
# print("Closing User Interface")
