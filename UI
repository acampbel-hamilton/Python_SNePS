#!/usr/local/bin/python3.5

import re
from Network import *
from LisParse import parse

import os
from cmd import Cmd

class UI(Cmd):
	network = None

	def __init__(self, completekey='tab', stdin=None, stdout=None):
		self.line = ""
		super().__init__(completekey, stdin, stdout)

	def preloop(self):
		UI.network = Network()
		UI.network.initialize()
		for name in ["T1", "T2", "T3", "T4"]:
			UI.network.terms[name] = Term(name)

	def precmd(self, line):
		if line[0] == '(' and line[-1] == ')':
			self.line = line
			line = line[1:-1]
		else:
			self.line = '(' + line + ')'
		return line

################ USER METHODS ################

	def do_build(self, args):
		"""Builds the specified term and adds it to the network.
		If an identical object exists, the existing object is returned"""
		slots = parse(self.line)[0][1:]
		print(slots)
		if not all([len(slot) > 1 for slot in slots]):
			print("Build command contains an unfilled slot")
			return
		rels, fillers = [list(l) for l in zip(*[(slot[0], slot[1:])
		 										for slot in slots])]
		for r in rels: # slots must be defined
			if not r in UI.network.slots.keys():
				print("Error: Use of undefined slot {}".format(r))
				return
		for n in [i for sl in fillers for i in sl]: #terms must be defined
			if not n in UI.network.terms.keys():
				print("Error: Use of undefined term {}".format(n))
				return
		if not len(rels) == len(set(rels)): #slots must be unique
			print("Error: Repeated slot")
			return
		cf = None
		for c in UI.network.caseframes.values():
			if set(c.slots) == set(rels):
				cf = c
				break
		if cf is None:
			print("Error: No caseframe with given slots <{}> is defined"
				.format(str(rels)[1:-1]))
			return
		print(rels)
		print(fillers)


	def do_describe(self, args):
		"""Prints a representation of the object specified by name"""
		name = args.split()[0]
		if UI.network.terms.get(name):
			print(UI.network.terms.get(name))
		elif UI.network.caseframes.get(name):
			print(UI.network.caseframes.get(name))
		elif UI.network.slots.get(name):
			print(UI.network.slots.get(name))
		elif UI.network.contexts.get(name):
			print(UI.network.contexts.get(name))
		else:
			print("Given name does not correspond to any object.")

	def do_dump(self, args):
		"""Prints the network. Should be rewritten"""
		print(UI.network)

	def do_exit(self, args):
		"""Exits the PySNePS UI"""
		print("Exiting PySNePS")
		raise SystemExit

	def do_list(self, args):
		"""Lists all instances defined on the network of the given object"""
		par = parse(self.line)[0][1:]
		if par == []:
			return
		if par[0] in ["caseframe", "caseframes"]:
			UI.network.listCaseframe()
		elif par[0] in ["context", "contexts"]:
			UI.network.listContexts()
		elif par[0] in ["semantic", "semantictype", "semantictypes"]:
			UI.network.listSemanticTypes()
		elif par[0] in ["slot", "slots"]:
			UI.network.listSlots()
		else:
			print("Error: Invalid argument to list")

	def do_shell(self, s):
		"""executes shell commands"""
		os.system(s)





if __name__ == "__main__":
	prompt = UI()
	prompt.prompt = '[> '
	prompt.cmdloop("Welcome to the rudimentary UI for PySNePS!")

# print("Welcome to the rudimentary User Interface for PSNePS")
#
# cmd = ""
# net = Network()
# net.initialize()
# while not cmd == "exit":
# 	usrin = input("[> ").strip()
# 	if not usrin[0] == '(':
# 		usrin = '(' + usrin + ')'
# 	par = parse(usrin)
# 	cmd = par[0][0]
# 	if cmd == "describe":
# 		pass
# 	elif cmd == "dump":
# 		print(net)
# 	elif cmd == "list":
# 		type = par[0][1]
# 		if type in ["semantic", "semantictype", "semantictypes"]:
# 			net.listSemanticTypes()
# 		elif type in ["caseframe", "caseframes"]:
# 			net.listCaseframe()
# 		elif type in ["context", "contexts"]:
# 			net.listContexts()
# 		elif type in ["slot", "slots"]:
# 			net.listSlots()
# 		else:
# 			print("Invalid list option.")
# 	print(par)
#
#
# print("Closing User Interface")
