#!/usr/local/bin/python3.5

import re
from Symbol import *
from Network import *
from LisParse import parse

import os
from functools import reduce
from cmd import Cmd

class UI(Cmd):
	network = None
	cmds = ""
	slot_filler = "\(\w+(\s+\w+)*\)\s*"
	qstr = "\"(\s*\w+)+\s*\""
	arg_gen = "\s+\w+\s*"

	def __init__(self, completekey='tab', stdin=None, stdout=None):
		self.line = ""
		self.recur = False
		super().__init__(completekey, stdin, stdout)

	def preloop(self):
		UI.network = Network()
		UI.network.initialize()

	def precmd(self, line):
		self.recur = True
		line = re.sub('\s+', ' ', line)
		if line[0] == '(' and line[-1] == ')':
			self.line = line
			line = line[1:-1]
		else:
			self.line = '(' + line + ')'
		return line

	def postcmd(self, stop, line):
		self.recur = False

	def _reval(self, args):
		"""recursively evaluates the arguments to any do_* method, allowing the
		only appropriate functions to be used as arguments"""
		if not UI.cmds: #create and store the list, instead of computing on call
			UI.cmds = "|".join(map((lambda s: s[3:]),
					filter((lambda i: re.match("^do_\w+$", i) is not None),
					[m for m in dir(self) if callable(getattr(self, m))])))
		subcmd = re.compile("\(((?P<cmd>{})\s+((?P<sf>{})|(?P<qstr>{})|(?P<arg_gen>{}))+)\)"
			.format(UI.cmds, UI.slot_filler, UI.qstr, UI.arg_gen))
		while subcmd.search(args) is not None:
			args = subcmd.sub((lambda mobj: self.onecmd(mobj.group(1))), args)
		return args

################ USER METHODS ################

	def do_build(self, args):
		"""Builds the specified term and adds it to the network.
		If an identical object exists, the existing object is returned"""
		args = re.sub('\((\w+)((\s+\w+)+)\)',
				(lambda mobj: '{0}{1}{0}{2}{0}'
					.format(chr(0), mobj.group(1), mobj.group(2))),
				self._reval(args))
		args = [i.strip() for i in args.split(chr(0)) if i]
		rels = args[::2]
		fillers = [i.split() for i in args[1::2]]
		for r in rels: # slots must be defined
			if not r in UI.network.slots.keys():
				print("Error: Use of undefined slot {}".format(r))
				return
		if not len(rels) == len(set(rels)): #slots must be unique
			print("Error: Repeated slot")
			return
		cf = None
		for c in UI.network.caseframes.values():
			if set(c.slots) == set(rels):
				cf = c
				break
		if cf is None: #specified slots correspond to an existing caseframe
			print("Error: No caseframe with given slots <{}> is defined"
				.format(str(rels)[1:-1]))
			return
		#if undefined terms are used, define them
		for n in [i for sl in fillers for i in sl]:
			if not n in UI.network.terms.keys():
				UI.network.terms[Sym(n)] = Term(n)
		for term in UI.network.terms.values(): #no identical term exists
			if isinstance(term, Molecular) and term.caseframe == cf and\
				[sorted(sl) for sl in sorted(fillers)] ==\
				 [sorted(sl) for sl in sorted(term.down_cableset.values())]:
				 print("Identical Term <{}>".format(repr(term)))
				 return
		Molecular.counter += 1
		term  = Molecular(Sym("M{}".format(Molecular.counter)), cf,
					down_cableset=dict(zip(rels, fillers)))
		UI.network.terms[Sym(term.name)] = term
		cf.terms.add(Sym(term.name))
		for i in range(len(rels)):
			for n in fillers[i]:
				UI.network.terms[n].up_cableset.update(
				{Sym(rels[i]):(UI.network.terms[n].up_cableset\
					.get(Sym(rels[i]), []) + [Sym(term.name)])})
		if self.recur:
			return Sym("M{}".format(Molecular.counter))

	def do_clear(self, args):
		""""calls bash clear command"""
		os.system('clear')

	def do_defContext(self, args):
		""" defines a new caseframe as specified by arguments in the form:
			definedContext [name] \"[docstring]\" ([parents]) ([hyps])"""
		m = re.match("^(?P<name>\s*\w+)\s*" + \
					"(?P<docstr>\"(\s*\w+)+\s*\")?" + \
					"(?(docstr)\s+\((?P<parents>(\s*\w+)+)\s*\))?" + \
					"(?(parents)\s+\((?P<hyps>(\s*\w+)+)\s*\)\s*)?$",args)

		if m is None:
			print("Error: Inappropriate number of arguments to defineContext")
		elif m.group('hyps'):
			UI.network.defineContext(m.group('name'), m.group('docstr'),
				set(m.group('parents').split()), set(m.group('hyps').split()))
		elif m.group('parents'):
			UI.network.defineContext(m.group('name'), m.group('docstr'),
				set(m.group('parents').split()))
		elif m.group('docstr'):
			UI.network.defineContext(m.group('name'), m.group('docstr'))
		else:
			UI.network.defineContext(m.group('name'))


	def do_defineFrame(self, args):
		"""defines a new caseframe as specified by arguments
		in the form: defineFrame [name] [semantic type] ([slots]) ([docstring])"""
		par = parse(self.line)[0]
		UI.network.defineCaseframe(par[1], par[2], par[3], " ".join(par[4]))

	def do_defPath(self, args):
		"""Defines path rule for path based inference"""
		par = parse(self.line)[0]
		UI.network.definePath(par[1], par[2])

	def do_defSlot(self, args): #requires testing
		"""defines a new slot as specified by arguments in the form :
			defineSlot [name] [type] ([docstring]) [pos_adj] [neg_adj] [min]
			[max]"""
		par = parse(self.line)[0]
		UI.network.defineSlot(par[1], par[2], " ".join(par[3]), Sym(par[4]),
			Sym(par[5]), int(par[6]), int(par[7]))

	def do_describe(self, args):
		"""Prints a representation of the object specified by name"""
		name = args.split()[0]
		if UI.network.terms.get(name):
			print(UI.network.terms.get(name))
		elif UI.network.caseframes.get(name):
			print(UI.network.caseframes.get(name))
		elif UI.network.slots.get(name):
			print(UI.network.slots.get(name))
		elif UI.network.contexts.get(name):
			print(UI.network.contexts.get(name))
		else:
			print("Given name does not correspond to any object.")

	def do_dump(self, args):
		"""Prints the network. Should be rewritten"""
		print(UI.network)

	def do_exit(self, args):
		"""Exits the PySNePS UI"""
		print("Exiting PySNePS")
		raise SystemExit

	def do_list(self, args):
		"""Lists all instances defined on the network of the given object"""
		args = args.split()[0]
		if args == []:
			return
		if args[0] in ["caseframe", "caseframes"]:
			UI.network.listCaseframe()
		elif args[0] in ["context", "contexts"]:
			UI.network.listContexts()
		elif args[0] in ["semantic", "semantictype", "semantictypes"]:
			UI.network.listSemanticTypes()
		elif args[0] in ["slot", "slots"]:
			UI.network.listSlots()
		else:
			print("Error: Invalid argument to list")

	def do_shell(self, s):
		"""executes shell commands"""
		try:
			print(eval(s))
		except:
			print("Python incompatible with limited interpreter")


if __name__ == "__main__":
	prompt = UI()
	prompt.prompt = '[> '
	prompt.cmdloop("Welcome to the rudimentary UI for PySNePS!")
