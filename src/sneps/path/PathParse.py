""" This file uses yacc-like syntax to match the tokens generated by PathLex and
use them to build Python_SNePS paths. """

# =====================================
# -------------- IMPORTS --------------
# =====================================

from . import PathLex
from ..ply import *
from ..Network import *
from ..SNError import SNError
from .. Path import BasePath, ComposedPaths, KPlusPath, KStarPath, AssertedPath, AndPaths, OrPaths, IRPath

# =====================================
# -------------- GLOBALS --------------
# =====================================

class SNePSPathError(SNError):
    pass

# Store variables needed to build the path in the current network
current_network = None
tokens = PathLex.tokens
producedPath = None

# =====================================
# -------------- RULES ----------------
# =====================================

def p_Path1(p):
    '''
    Path :              SlotName
    '''
    p[0] = BasePath(current_network.find_slot(p[1]))
    global producedPath
    producedPath = p[0]
def p_Path2(p):
    '''
    Path :              ReverseSlotName
    '''
    p[0] = BasePath(current_network.find_slot(p[1][:-1]), backward=True)
    global producedPaths
    producedPath = p[0]
def p_Path3(p):
    '''
    Path :              AssertedNode
         |              ConversePath
         |              KPath
         |              MultiPath
         |              IRPath
    '''
    p[0] = p[1]
    global producedPath
    producedPath = p[0]

# ==============================================================================

# e.g. !
def p_AssertedPath(p):
    '''
    AssertedNode :      ExPoint
    '''
    p[0] = AssertedPath(current_network)

# ==============================================================================

# e.g. converse(member)
def p_ConversePath(p):
    '''
    ConversePath :      Converse LParen Path RParen
    '''
    p[3].reverse()
    p[0] = p[3]

# ==============================================================================

# e.g. kplus(member)
def p_KPath1(p):
    '''
    KPath :             KPlus LParen Path RParen
    '''
    p[0] = KPlusPath(p[3])
def p_KPath2(p):
    '''
    KPath :             KStar LParen Path RParen
    '''
    p[0] = KStarPath(p[3])

# ==============================================================================

# e.g. compose(member)
def p_MultiPath1(p):
    '''
    MultiPath :         Compose LParen Paths RParen
              |         LBracket Paths RBracket
    '''
    if len(p) == 4:
        p[0] = ComposedPaths(p[2])
    else:
        p[0] = ComposedPaths(p[3])
def p_MultiPath2(p):
    '''
    MultiPath :         Or LParen Paths RParen
    '''
    p[0] = OrPaths(p[3])
def p_MultiPath3(p):
    '''
    MultiPath :         And LParen Paths RParen
    '''
    p[0] = AndPaths(p[3])

# ==============================================================================

# e.g. irreflexive-restrict(member)
def p_IRPath(p):
    '''
    IRPath :            IrreflexiveRestrict LParen Path RParen
    '''
    p[0] = IRPath(p[3])

# ==============================================================================

def p_Paths(p):
    '''
    Paths :             Path
          |             Paths Comma Path
    '''
    if len(p) == 2:
        p[0] = [p[1]]
    else:
        p[0] = p[1] + [p[3]]

# ==============================================================================

def p_error(p):
    if p is None:
        raise SNePSPathError("PARSING FAILED: Term reached end unexpectedly.")
    else:
        raise SNePSPathError("PARSING FAILED: Syntax error on token '{}' ('{}')".format(p.type, p.value))

# =====================================
# ------------ RULES END --------------
# =====================================

def path_parser(path, network):
    """ Uses lex and yacc to produce a Path instance from a string. """

    global current_network
    current_network = network
    path_parser = yacc.yacc()
    if path != '':
        try:
            # Parse import as path
            path_parser.parse(path, lexer=PathLex.path_lexer)

            # Returns the produced path, with a string representation
            global producedPath
            return producedPath

        except SNError as e:
            if type(e) is not SNePSPathError:
                print("PARSING FAILED:\n\t", end='')
            raise SNePSPathError(e)
    else:
        return None
